// efficient time to live implementation with sorted sets

var Set = require('..');

// a ttl set
function TTL() {
  this._set = new Set({
    hash: function(item) {
      return item.key;
    },
    compare: function(a, b) {
      return a.expire - b.expire;
    }
  });
}

// returns true when added, false when it already existed
TTL.prototype.add = function(key, ms) {
  this.cleanup(); // might not need to call this on every update
  return this._set.add({
    key: key,
    expire: Date.now() + ms
  }) === null;
};

// returns true when added, false when it already existed
TTL.prototype.set = function(key, time) {
  this.cleanup();
  return this._set.add({
    key: key,
    expire: time
  }) === null;
};

// returns whether the set contains the given key
TTL.prototype.has = function(key) {
  this.cleanup();
  return this._set.has({key: key});
};

// returns number of keys removed
TTL.prototype.cleanup = function() {
  return this._set.gut(null, {expire: Date.now() - 1});
};

var ttl = new TTL();

// clean up storage every tenth of a second
var interval = setInterval(ttl.cleanup.bind(ttl), 100);

ttl.add('hello', 400);
ttl.add('world', 500);

setTimeout(function() {
  console.log(ttl._set.length); // should be 2
  console.log('hello should exist:\t' + (ttl.has('hello') ? 'ok' : 'bad'));
  console.log('world should exist:\t' + (ttl.has('world') ? 'ok' : 'bad'));
}, 350);

ttl.cleanup();

setTimeout(function() {
  console.log(ttl._set.length); // should be 1
  console.log('hello should not exist:\t' + (ttl.has('hello') ? 'bad' : 'ok'));
  console.log('world should exist:\t' + (ttl.has('world') ? 'ok' : 'bad'));
}, 450);

ttl.cleanup();

setTimeout(function() {
  console.log(ttl._set.length); // should be 0
  console.log('hello should not exist:\t' + (ttl.has('hello') ? 'bad' : 'ok'));
  console.log('world should not exist:\t' + (ttl.has('world') ? 'bad' : 'ok'));
  // clear event loop, terminates process
  clearInterval(interval);
}, 550);

ttl.cleanup();
