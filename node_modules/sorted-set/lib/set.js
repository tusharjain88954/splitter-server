var intersect = require('./intersect-sorted');
var intersectKeys = require('./intersect-unique');

var slice = Array.prototype.slice;

var P = 1 / Math.E;

function randomLevel() {
  var level = 1;
  while (Math.random() < P)
    level++;
  return level < 32 ? level : 32;
}

function compare(a, b) {
  if (a < b) return -1;
  if (b < a) return 1;
  return 0;
}

function hash(value) {
  return value;
}

function getter(field) {
  if (/^[a-z_\$][a-z_\$\d]*$/.test(field))
    return '.' + field;
  return '[' + JSON.stringify(field) + ']';
}

function coerceCompare(value) {
  if (!value)
    return compare;
  if (typeof value === 'function')
    return value;
  if (typeof value !== 'string')
    throw new TypeError('expected compare function');
  var get = getter(value);
  var body = 'if (a' + get + ' < b' + get + ') return -1;\n';
  body += 'if (b' + get + ' < a' + get + ') return -1;\n';
  body += 'return 0;';
  return new Function('a', 'b', body);
}

function coerceHash(value) {
  if (!value)
    return hash;
  if (typeof value === 'function')
    return value;
  if (typeof value !== 'string')
    throw new TypeError('expected hash function');
  return new Function('value', 'return value' + getter(value) + ';');
}

function Level(next, span) {
  this.next = next;
  this.span = span;
}

// value is value of node, sorted (by compare) and unique (by hash)
function Node(level, value) {
  this.value = value;
  this.next = new Array(level);
  this.prev = null;
}

function Set(options) {
  if (!(this instanceof Set))
    return new Set();
  options || (options = {});
  this._compare = coerceCompare(options.compare);
  this._hash = coerceHash(options.hash);
  this._unique = !!options.unique;
  this.empty();
}

Set.intersect = function() {
  return intersect.call(Set, slice.call(arguments));
};

Set.intersectKeys = function() {
  return intersectKeys.call(Set, slice.call(arguments));
};

Set.prototype.add = function(value) {
  var hash = this._hash(value);
  if (hash === '__proto__')
    throw new Error('invalid hashed value __proto__');
  var current = this._map[hash], old;
  if (current) {
    old = current.value;
    if (this._compare(old, value) === 0 ||
      (!current.prev || this._compare(current.prev.value, value) < 0) &&
      (!current.next[0].next ||
        this._compare(value, current.next[0].next.value) < 0)) {
      current.value = value;
      return old;
    }
    this._remove(current.value);
  }
  var node = this._insert(value);
  if (!node) {
    current && this._insert(old);
    // TODO: can we defer _remove until after insert?
    throw new Error('unique constraint violated');
  }
  this._map[hash] = node;
  return current ? old : null;
};

Set.prototype.has = function(value) {
  return !!this._map[this._hash(value)];
};

Set.prototype.get = function(value) {
  var entry = this._map[this._hash(value)];
  return entry ? entry.value : null;
};

Set.prototype.del = function(value) {
  var hash = this._hash(value), entry = this._map[hash];
  if (entry) {
    // TODO: entry.value or value?
    this._remove(entry.value);
    delete this._map[hash];
    return entry.value;
  }
  return null;
};

Set.prototype.rank = function(value) {
  if (!this._map[this._hash(value)])
    return -1;
  var i = this._level - 1, node = this._head, next = null, rank = -1;
  for (; i >= 0; i--) {
    while ((next = node.next[i].next) && this._compare(next.value, value) <= 0) {
      rank += node.next[i].span;
      node = next;
    }
    // TODO: check node.value?
    if (node.value && this._compare(node.value, value) === 0) {
      return rank;
    }
  }
  return -1;
};

Set.prototype.count = function(min, max) {
  var type = this._range(min, max), node = null, next = null;
  if ((type & 1) === 0)
    return 0;
  if (type === 1)
    return this.length;
  if (min == null)
    node = this._head.next[0].next;
  else
    // TODO: will this never return null?
    node = this._first(min);
  if (this._compare(max, node.value) < 0)
    return 0;
  var rank = this.rank(node.value);
  node = this._next(max, node);
  while ((next = node.next[0].next) && this._compare(next.value, max) <= 0) {
    node = next;
  }
  return this.rank(node.value) - (rank - 1);
};

Set.prototype.range = function(min, max) {
  var type = this._range(min, max), node = null, value = null;
  if ((type & 1) === 0)
    return [];
  if (type === 1)
    return this.values();
  if (min == null)
    node = this._head.next[0].next;
  else
    // TODO: will this never return null?
    node = this._first(min);
  var result = [];
  if (max == null) {
    for (; node; node = node.next[0].next) {
      result.push(node.value);
    }
  } else {
    for (; node && this._compare(node.value, max) <= 0; node = node.next[0].next) {
      result.push(node.value);
    }
  }
  return result;
};

Set.prototype.slice = function(start, end) {
  if (start == null) start = 0;
  else if (start < 0) start = Math.max(this.length + start, 0);
  if (end == null) end = this.length;
  else if (end < 0) end = this.length + end;

  if (start > end || start >= this.length)
    return [];
  if (end > this.length)
    end = this.length;

  if (start === 0 && end === this.length)
    return this.values();

  var i = 0, length = end - start, result = new Array(length);
  var node = start > 0 ? this._get(start) : this._head.next[0].next;

  for (; length--; node = node.next[0].next)
    result[i++] = node.value;

  return result;
};

// remove the smallest element from the set
Set.prototype.shift = function() {
  if (!this.length)
    return null;
  var value = this._head.next[0].next.value;
  this._remove(value);
  return value;
};

// remove the largest element from the set
Set.prototype.pop = function() {
  if (!this.length)
    return null;
  var value = this._tail.value;
  this._remove(value);
  return value;
};

Set.prototype.peek =
Set.prototype.head = function() {
  return this.length ? this._head.next[0].next.value : null;
};

Set.prototype.tail = function() {
  return this.length ? this._tail.value : null;
};

Set.prototype.gut = function(min, max) {
  var type = this._range(min, max), removed = 0;
  if ((type & 1) === 0)
    return 0;
  if (type === 1)
    return removed = this.length, this.empty(), removed;
  var next, node = this._head, update = new Array(32), i = this._level - 1;
  if (min == null) {
    for (; i >= 0; i--)
      update[i] = node;
    node = update[0];
  } else {
    for (; i >= 0; i--) {
      while ((next = node.next[i].next) && this._compare(next.value, min) < 0)
        node = next;
      update[i] = node;
    }
  }
  node = node.next[0].next;

  if (max == null) {
    // TODO: can optimize?
    while (node) {
      next = node.next[0].next;
      this._removeNode(node, update);
      delete this._map[this._hash(node.value)];
      removed++;
      node = next;
    }
  } else {
    while (node && this._compare(node.value, max) <= 0) {
      next = node.next[0].next;
      this._removeNode(node, update);
      delete this._map[this._hash(node.value)];
      removed++;
      node = next;
    }
  }
  this.length -= removed;
  return removed;
};

Set.prototype.gutSlice = function(start, end) {
  var len = this.length;
  if (!len)
    return 0;

  if (start == null) start = 0;
  else if (start < 0) start = Math.max(len + start, 0);
  if (end == null) end = len;
  else if (end < 0) end = len + end;

  if (start > end || start >= len)
    return 0;
  if (end > len)
    end = len;

  if (start === 0 && end === len)
    return this.empty(), len;

  var node = this._head, update = new Array(32), traversed = -1, next;
  for (var i = this._level - 1; i >= 0; i--) {
    while ((next = node.next[i].next) && (traversed + node.next[i].span) < start) {
      traversed += node.next[i].span;
      node = next;
    }
    update[i] = node;
  }

  var removed = 0;
  traversed++;
  node = node.next[0].next;

  while (node && traversed < end) {
    next = node.next[0].next;
    this._removeNode(node, update);
    delete this._map[this._hash(node.value)];
    removed++;
    traversed++;
    node = next;
  }
  this.length -= removed;
  return removed;
};

// intersect values
// TODO: optimized two-set intersect?
Set.prototype.intersect = function() {
  var sets = slice.call(arguments);
  sets.unshift(this);
  return intersect.call(this, sets);
};

Set.prototype.intersectKeys = function() {
  var sets = slice.call(arguments);
  sets.unshift(this);
  return intersectKeys.call(this, sets);
};

Set.prototype.values = function() {
  if (!this.length)
    return [];
  var i = 0, array = new Array(this.length), node = this._head.next[0].next;
  for (; node; node = node.next[0].next)
    array[i++] = node.value;
  return array;
};

// CAUTION: THIS MAY DO FUNNY THINGS IF MODIFIED DURING OPERATION
Set.prototype.each = function(fn, me) {
  if (!this.length)
    return;
  me || (me = this);
  var node = this._head.next[0].next;
  for (; node; node = node.next[0].next)
    fn.call(me, node.value);
};

// TODO: does not currently handle unique conflicts
// TODO: does not handle map hash conflicts
// TODO: should this just trust the user? how to handle the errors on failure...
// CAUTION: THIS TRUSTS THE USER TO NOT DIRECTLY MODIFY THE SET DURING OPERATION
Set.prototype.map = function(fn, me) {
  // don't need to do anything if empty
  if (!this.length)
    return;

  // the context should default to the Set
  me || (me = this);

  // get the first node in the sorted set
  var node = this._head.next[0].next;
  // the new value for the node
  var value = null;
  // storage for the previous node and previous mapped value
  var delayNode = null, delayValue = null;
  // temporary storage for old and new hashes during comparison
  var hashNew = null, hashOld = null;

  // iterate through the lowest level of the skip list
  for (; node; node = node.next[0].next) {
    if (node.marked) {
      // if already processed (but placed ahead), don't reprocess
      // just skip ahead if no delayed node
      if (!delayNode)
        continue;
      // otherwise let the delayed node section do its thing
      value = node.value;
    } else {
      // map the node's value to the new value with which to replace
      value = fn.call(me, node.value);
    }

    // if the previous entry passed the first check, attempt to update in-place
    if (delayNode) {
      // but only update in-place if the delayed value is less than the value
      // for the current node
      if (this._compare(delayValue, value) < 0) {
        // if the hashes have changed, move the node to the correct place in the
        // lookup map
        if (hashNew !== hashOld) {
          delete this._map[hashOld];
          this._map[hashNew] = delayNode;
        }
        // and update the delayed node's value with the delayed value
        delayNode.value = delayValue;
      } else {
        // but if we can't update in-place, remove the old value and just add
        // the new value, which places it in the correct position in the set
        this._remove(delayNode.value);
        delayNode = this._insert(delayValue);
        // mark the entry as processed
        delayNode.marked = true;
        // update the map to use the correct key if necessary
        if (hashNew !== hashOld)
          delete this._map[hashOld];
        // put the new node in the map, either as a new entry or replacing an
        // existing entry
        this._map[hashNew] = delayNode;
      }
      // empty the delayed node, so it doesn't look like there is one on the
      // next pass
      delayNode = null;
      // if marked, don't reprocess
      if (node.marked)
        continue;
    }

    // calculate the old and new hashes, which will be used no matter what
    hashNew = this._hash(value);
    hashOld = this._hash(node.value);

    // if the node's values are the same, just update in-place
    if (this._compare(value, node.value) === 0) {
      // but make sure to put it in the right place in the map, as above
      if (hashNew !== hashOld) {
        delete this._map[hashOld];
        this._map[hashNew] = node;
      }
      // and update the node's value
      node.value = value;
    } else if (!node.prev || this._compare(node.prev.value, value) < 0) {
      // if we might be able to delay processing of the node, store the node
      // (and old value), and the new value
      delayNode = node;
      delayValue = value;
    } else {
      // if we can't update in-place at all, fall back to removing and re-adding
      this._remove(node.value);
      // because this value is less than the previous value, it won't collide
      // during further mapping
      delayNode = this._insert(value);
      // update the map to use the correct key if necessary
      if (hashNew !== hashOld)
        delete this._map[hashOld];
      // put the new node in the map, either as a new entry or replacing an
      // existing entry
      this._map[hashNew] = delayNode;
      // set to null so it doesn't stick around
      delayNode = null;
    }
  }

  // if the last entry in the map could be updated in-place, go ahead and do so
  if (delayNode) {
    // still making sure that the hash is correct, and updating it if not
    if (hashNew !== hashOld)
      delete this._map[hashOld];
    // while also setting it if new
    this._map[hashNew] = delayNode;
    // and still updating the node's value
    delayNode.value = delayValue;
  }
  // TODO: DRY this last block?
};

Set.prototype.clear =
Set.prototype.empty = function() {
  this.length = 0;
  this._level = 1;
  this._map = Object.create(null);
  this._head = new Node(32, null, 0);
  this._tail = null;
  for (var i = 0; i < 32; i++) {
    // hrm
    this._head.next[i] = new Level(null, 0);
  }
};

// 0: no content
// 1: full range
// 2: out of bounds
// 3: sub range
Set.prototype._range = function(min, max) {
  if (!this.length)
    return 0;
  var head = this._head.next[0].next;
  if ((min == null || this._compare(min, head.value) <= 0) &&
    (max == null || this._compare(this._tail.value, max) <= 0))
    return 1;
  if ((min != null && this._compare(this._tail.value, min) < 0) ||
    (max != null && this._compare(max, head.value) < 0) ||
    (max != null && min != null && this._compare(max, min) < 0))
    return 2;
  return 3;
};

// precondition: does not already have value
// in unique mode, returns null if the value already exists
Set.prototype._insert = function(value) {
  var update = new Array(32), rank = new Array(32), node = this._head, next = null, i = this._level - 1, cmp;
  for (; i >= 0; i--) {
    rank[i] = i === (this._level - 1) ? 0 : rank[i + 1];
    // TODO: optimize some more?
    while ((next = node.next[i].next) && (cmp = this._compare(next.value, value)) <= 0) {
      if (cmp === 0) {
        if (this._unique)
          return null;
        break;
      }
      rank[i] += node.next[i].span;
      node = next;
    }
    if (this._unique && node.value && this._compare(node.value, value) === 0)
      return null;
    update[i] = node;
  }
  if (this._unique && node.value && this._compare(node.value, value) === 0)
    return null;
  var level = randomLevel();
  if (level > this._level) {
    // TODO: optimize
    for (i = this._level; i < level; i++) {
      rank[i] = 0;
      update[i] = this._head;
      update[i].next[i].span = this.length;
    }
    this._level = level;
  }
  node = new Node(level, value);
  // TODO: optimize?
  for (i = 0; i < level; i++) {
    node.next[i] = new Level(update[i].next[i].next, update[i].next[i].span - (rank[0] - rank[i]));
    update[i].next[i].next = node;
    update[i].next[i].span = (rank[0] - rank[i]) + 1;
  }

  for (i = level; i < this._level; i++)
    update[i].next[i].span++;

  node.prev = (update[0] === this._head) ? null : update[0];
  if (node.next[0].next)
    node.next[0].next.prev = node;
  else
    this._tail = node;
  this.length++;
  return node;
};

// TODO: optimize when index is less than log(N) from the end
Set.prototype._get = function(index) {
  var node = this._head, distance = -1;
  for (var i = this._level - 1; i >= 0; i--) {
    while (node.next[i].next && (distance + node.next[i].span) <= index) {
      distance += node.next[i].span;
      node = node.next[i].next;
    }
    if (distance === index)
      return node;
  }
  return null;
};

// precondition: min is a valid "minimum value"
Set.prototype._first = function(min) {
  var node = this._tail;
  if (!node || this._compare(node.value, min) < 0)
    return null;
  node = this._head;
  for (var next = null, i = this._level - 1; i >= 0; i--)
    while ((next = node.next[i].next) && this._compare(next.value, min) < 0)
      node = next;
  return node.next[0].next;
};

// find node after node when value >= specified value
Set.prototype._next = function(value, node) {
  if (!this._tail || this._compare(this._tail.value, value) < 0)
    return null;
  // search upwards
  for (var next = null; (next = node.next[node.next.length - 1].next) && this._compare(next.value, value) < 0; )
    node = next;
  if (this._compare(node.value, value) === 0)
    return node;
  // search downwards
  for (var i = node.next.length - 1; i >= 0; i--) {
    while ((next = node.next[i].next) && this._compare(next.value, value) < 0)
      node = next;
    if (this._compare(node.value, value) === 0)
      return node;
  }
  return node.next[0].next;
};

Set.prototype._remove = function(value) {
  var update = new Array(32), node = this._head, next = null, i = this._level - 1;
  for (; i >= 0; i--) {
    while ((next = node.next[i].next) && this._compare(next.value, value) < 0)
      node = next;
    update[i] = node;
  }
  node = node.next[0].next;
  if (!node || this._compare(node.value, value) !== 0)
    return false;
  // delete
  this._removeNode(node, update);
  this.length--;
  return true;
};

Set.prototype._removeNode = function(node, update) {
  var next = null, i = 0, n = this._level;
  for (; i < n; i++) {
    if (update[i].next[i].next === node) {
      update[i].next[i].span += node.next[i].span - 1;
      update[i].next[i].next = node.next[i].next;
    } else {
      update[i].next[i].span--;
    }
  }
  if (next = node.next[0].next)
    next.prev = node.prev;
  else
    this._tail = node.prev;
  while (this._level > 1 && !this._head.next[this._level - 1].next)
    this._level--;
};

module.exports = Set;
