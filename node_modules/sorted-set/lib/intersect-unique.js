function binaryIntersect(a, b) {
  var lookup = a._map, result = [], node = b._head.next[0].next;
  for (; node; node = node.next[0].next)
    if (lookup[b._hash(node.value)] !== undefined)
      result.push(node.value);
  return result;
}

function ternaryIntersect(a, b, c) {
  var lookup = Object.create(null), result = [], hash;
  var i = a._head.next[0].next, j = b._head.next[0].next, k = c._head.next[0].next;
  for (; i; i = i.next[0].next)
    lookup[a._hash(i.value)] = 0;
  for (; j; j = j.next[0].next)
    if (lookup[hash = b._hash(j.value)] === 0)
      lookup[hash] = 1;
  for (; k; k = k.next[0].next)
    if (lookup[c._hash(k.value)] === 1)
      result.push(k.value);
  return result;
}

function intersect(sets) {
  if (!sets.length)
    return [];
  if (sets.length === 1)
    return sets[0].values();
  var n = sets.length - 1;
  // abort if one of the sets has no values
  for (var i = n; i >= 0; i--)
    if (!sets[i].length) // abort
      return [];
  // optimized for two sets
  if (sets.length === 2)
    return binaryIntersect(sets[0], sets[1]);
  // optimized for three sets
  if (sets.length === 3)
    return ternaryIntersect(sets[0], sets[1], sets[2]);
  // all-purpose
  var nodes = new Array(sets.length);
  for (i = n; i >= 0; i--)
    nodes[i] = sets[i]._head.next[0].next;
  var lookup = Object.create(null), node = nodes.shift(), set = sets.shift();
  for (; node; node = node.next[0].next)
    lookup[set._hash(node.value)] = 0;
  var x, j, hash;
  for (i = 0, n = sets.length - 1; i < n; i++) {
    x = 0;
    j = i + 1;
    for (node = nodes[i], set = sets[i]; node; node = node.next[0].next) {
      if (lookup[hash = set._hash(node.value)] === i) {
        lookup[hash] = j;
        x++;
      }
    }
    if (!x) // useful?
      return [];
  }
  var result = [];
  for (node = nodes[i], set = sets[i]; node; node = node.next[0].next)
    if (lookup[set._hash(node.value)] === i)
      result.push(node.value);
  return result;
}

module.exports = intersect;
